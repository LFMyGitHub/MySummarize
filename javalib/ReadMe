Android Studio中设置运行Java代码
    在运行处编辑运行Java的配置
    添加一个Application
    Name随意
    Mian class为java代码main函数所在路径(全路径)
    选择对应Module

程序运行时可保存数据的六个地方
    寄存器(最快保存区域/处理器内部/数量有限由编译器分配/无直接控制权)
    堆栈(驻留于常规RAM随机访问存储器/通过堆栈指针获得处理的直接支持)
    堆(常规用途内存池也在RAM区域/不必知道从堆里分配多少存储空间,也不必知道数据在堆中停留时长)
    静态存储
    常数存储
    非RAM存储

1.面向对象(OOP)三大特性
封装：就是把客观事物封装成抽象的类，定义数据的可访问属性（私有、公有）
继承：可以让一个类型获取另外一个类型的属性的方式。分为实现继承和接口继承(子类必须提供实现的能力)
多态：一个类实例的相同方法在不同情形有不同表现形式，使具有不同的内部结构的对象可以共享相同的外部接口。

2.六大基本原则(soldi)
单一职责原则：功能单一
开闭原则：扩展开放，修改封闭
里氏替换原则：子类可以替换父类出现
依赖倒置原则：具体依赖抽象，上层依赖下层(面向接口编程)
接口分离原则：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
迪米特原则：最小依赖原则

3.String、StringBuilder、StringBuffer区别
运行速度：StringBuilder>StringBuffer>String
原因：String为字符串常量，另外两个为字符串变量
线程安全：StringBuilder是线程不安全的，StringBuffer是线程安全的
原因：StringBuilder的方法没有synchronized关键字，不能保证线程安全

String：适用于少量的字符串操作的情况
StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况
StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况

4.Java线程池
newFixedThreadPool：创建固定大小的线程池，poolCoreSize和maxPoolSize 相等，到达coreSize,则将新的任务放到缓存队列，有线程执行完毕，直接去取。
newSingleThreadExecutor：创建一个单线程的线程池，核心池的大小和最大池大小都为1.
newCacheThreadPool：无大小限制的线程池，提交一个任务就创建一个线程执行。

corePoolSize：核心池的大小
maximumPoolSize：线程池最大线程数
keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止
unit：参数keepAliveTime的时间单位，有7种取值
workQueue：一个阻塞队列，用来存储等待执行的任务
threadFactory：线程工厂，主要用来创建线程
handler：表示当拒绝处理任务时的策略

自定义线程池合理配置大小
如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1
如果是IO密集型任务，参考值可以设置为2*NCPU

5.Java集合
![img](https://github.com/LFMyGitHub/MySummarize/blob/master/img/jihe.png)
按类型分：
set(集，基于HashMap实现，不能包含有重复元素)
HashSet：无序，HASH算法存储集合中的元素，具有良好的存取和查找性能
    LinkedHashSet：使用链表维护元素的次序
SortedSet：有序，主要用于排序操作
    TreeSet：确保元素处于排序状态
EnumSet：专门为枚举类设计的集合类
list(列表)
    Vector：基于Array的List，封装了Array所不具备的一些功能方便我们使用，线程安全的
    ArrayList：与Vector一样，线程不安全的
    LinkedList：不是基于Array的，每个节点包含节点本身数据data以及下一个节点信息nextNode(添加删除操作不需要像基于Array的List一样进行大量数据移动的操作)
    所有的list只能容纳单个不同类型的对象组成的表
    所有的List中可以有相同的元素
    所有的List中可以有null元素
    基于Array的List（Vector，ArrayList）适合查询，而LinkedList（链表）适合添加，删除操作
Queue：模拟队列数据结构先进先出
    PriorityQueue：按照队列元素的大小进行重新排序
    Deque：基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素
map(映射)：保存具有映射关系的数据
    HashMap：和HashSet集合一样不能保证元素的顺序(对实际对象的强引用)
        LinkedHashMap：使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致
    SortedMap
        TreeMap(红黑树数据结构，每个key-value对即作为红黑树的一个节点)，两种排序方式：自然排序、定制排序
    WeakHashMap：key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对(对实际对象的弱引用)
    IdentityHashMap：实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等
    EnumMap：与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值
按接口分：
Collection和Map

顺序表(数组)和链表的比较
特点对比：
1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；
2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；
3、存储空间上，链表由于带有指针域，存储密度不如数组大；
4、按序号查找时，数组可以随机访问，时间复杂度为O(1)，而链表不支持随机访问，平均需要O(n)；
5、按值查找时，若数组无序，数组和链表时间复杂度均为O(1)，但是当数组有序时，可以采用折半查找将时间复杂度降为O(logn)；
6、插入和删除时，数组平均需要移动n/2个元素，而链表只需修改指针即可；
7、空间分配方面，数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；
数组应用场景：
1、注重存储密度；
2、经常做的运算是按序号访问数据元素；
3、数组更容易实现，任何高级语言都支持；
4、构建的线性表较稳定。
链表应用场景：
1、对线性表的长度或者规模难以估计；
2、频繁做插入删除操作；
3、构建动态性比较强的线性表。

6.Java内存模型
内存是如何分配的，成员变量、静态变量、局部变量、对象等各自分配到哪一个区：
栈内存：在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配，栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失
堆内存：用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理(java占内存的原因，回收的不确定性)

成员变量：
类变量(static修饰)：
1、 jvm把.class类加载到非堆里，然后在堆中为.class的类变量开辟内存；堆中的地址存放于栈以便高速访问；
2、类变量的生命周期一直持续到整个“系统”关闭；
3、一旦赋值它的值就在你new出来的任何一个实例中具有相同的值；
实例变量：
1、当你用java关键字new一个对象时，jvm将在堆里创建对象，并在堆中开辟空间给变量（空间不一定连续），然后根据零散的堆内存地址，通过哈希算法得到“物理地址”；
2、实例变量的生命周期：当实例变量的引用丢失后，将被gc回收，但并不是马上释放堆中内存；
3、每一个new出来的新实例都可以对他赋予自己需要的值
同一个jvm里，一个类变量只需要分配一个内存空间；对于实例变量，每创建一次对象，都需要为实例变量分配一次内存空间；

垃圾回收机制：
年轻代：1 Eden 区 和2个Survivor 区
年老代
永久代
分代回收分为了三个代，每个代的垃圾回收时机和频率是不一样的，因此采用的回收算法也不一样。
总的来说：年轻代的回收频率很高，对象的生命周期比较短暂，当经过一定次数的回收周期之后，
年轻代的对象还存活的话，就会被移动到年老代，年老代的回收比较耗时，回收频率较低，回收成本较大。

7.设计模式
https://github.com/LFMyGitHub/MySummarize/tree/master/designpatterns