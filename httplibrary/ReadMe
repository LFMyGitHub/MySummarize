HTTP简介：
应用层的面向对象的协议，简便、快速，适用于分布式超媒体信息系统。1990年提出
特点：
1.支持c/s(客户/服务器)模式
2.简单快速：客户像服务器请求服务时，只需传送请求方法(GET/POST/HEAD)和路径，每种方法规定了客户与服务
器联系的类型不同。因为HTTP协议简单，使得HTTP服务器程序规模小，因而通讯速度非常快。
3.灵活：允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。
4.无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户应答后，即断开连接。节省传输时间。
5.无状态：协议对于事务处理没有记忆能力。后续处理需要前面信息必须重传，导致每次连接传送的数据量增大。
服务器不需要先前信息时应答就快。
格式：
http://host[":"port][abs_path]
http表示通过HTTP协议来定位网络资源
host表示合法的Internet主机域名或IP地址
port指定一个端口号，为空则默认使用端口80
abs_path指定请求资源的URI

HTTP请求报文
https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/http_request.jpg
一般格式：请求行、请求报头、空行、请求数据4个部分组成。
请求行：请求方法、URL字段和HTTP协议版本组成
格式：Method Request-URI HTTP-Version CRLF
Method表示请求方法
Request-URI是一个统一资源标识符
HTTP-Version表示请求的HTTP协议版本
CRLF表示回车和换行(除作为结尾的CRLF外，不允许出现单独的CR或LF字符)
HTTP八种请求方法：
1.GET：请求获取Request-URI所标识的资源
2.POST：在Request-URI所标识的资源后附加新的数据
3.HEAD：请求获取Request-URI所标识的资源的响应消息报头
4.PUT：请求服务器存储一个资源，并用Request-URI作为其标识
5.DELETE：请求服务器删除Request-URI所标识的资源
6.TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断
7.CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
8.OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求
ex:GET http://xxxxx HTTP/1.1
请求报头：
在请求行之后会有0个或多个请求报头，每个请求报头包含一个名字和值，用:分割。请求报头以一个空行发送回车和
换行符通知服务器以下不会有请求报头。
请求数据：
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关
的最常用的请求头是Content-Type和Content-Length

HTTP响应报文
https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/http_reponse.jpg
一般格式：由状态行、消息报头、空行、响应正文组成。
状态行
格式：HTTP-Version Status-Code Reason-Phrase CRLF
HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述
状态码由三个数字组成，第一个数字定义了响应的类别，且有五中可能：
100-199：指示信息，表示请求已接收，继续处理
200-299：请求成功，表示请求已被成功接收，理解，接受
300-399：重定向，要完成请求必须要进行更进一步的操作
400-499：客户端错误，请求有语法错误，或请求无法实现
500-599：服务器端错误，服务器未能实现合法的请求
常见状态码：
200 OK：客户端请求成功
400 Bad Request：客户端请求有语法错误，不能被服务端理解
401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
403 Forbidden：服务器收到请求，拒绝提供服务
500 Internal Server Error：服务器发生不可预期的错误
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
ex：HTTP/1.1 200 OK

HTTP消息报头
通用报头：既可以出现在请求报头，也可以出现响应报头中
Date：消息产生的时间和日期
Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定close选项，通知服务器在响应完成之后关闭连接。
Cache-Control：指定缓存指令，缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现)，且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)
请求报头：通知服务器关于客户端请求的信息
典型请求头：
Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
User-Agent：发送请求的浏览器类型、操作系统等信息
Accept：客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息
Accept-Encoding：客户端可识别的数据编码
Accept-Language：表示浏览器所支持的语言类型
Connection：允许客户端或服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接
Transfer-Encoding：告知接收端为保证报文的可靠传输，对报文采用什么编码方式
响应报头：服务器传递自身信息的响应
常见响应报头：
Location：用于重定向接受者到一个新位置，常用在更换域名的时候
Server：包含服务器用来处理请求的系统信息，与User-Agent请求报头对应
实体报头：定义被传输资源的信息，可以用于请求，也可以用于响应
常用实体报头：
Content-Type：指明发送给接受者的实体正文的媒体类型(MIME)
Content-Length：实体正文的长度
Content-Language：描述资源所用的自然语言，没有设置则认为实体内容将提供给所有的语言阅读
Content-Encoding：指明数据的压缩方式，因而要获得Content-Type报头域中所引用的媒体类型必须采用相应的解码机制。
Last-Modified：指示资源的最后修改日期
Expires：实体报头给出响应过期的时间和日期

利用Fiddler工具进行网络数据抓包

HttpClient与HttpURLConnection
HttpClient：
Android SDK中包含了HttpClient，在Android6.0版本删除了该类库，如果仍想使用解决办法是：
Eclipse：在libs中加入org.apache.http.legacy.jar(**sdk/platforms/android-23/optional目录下)
Android Studio：相应module下build.gradle中加入：
android{
    useLibrary 'org.apache.http.legacy'
}

HttpURLConnecion

网络通信框架Volley(2013Google)
应用场景：数据量不大，通信频繁的操作
基于请求队列依次请求，开发者只需要将请求放入请求队列就可以了。
Volley结构图：https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/volley.png
Volley分为三个线程：主线程、缓存调度线程、网络调度线程，首先请求会加入缓存队列，如果发现相应的缓存结果就
直接读取缓存并解析，然后回调给主线程；如果没在缓存中找到结果，则将这条请求加入网络队列，然后发送HTTP请求，
解析响应并写入缓存，并回调给主线程。
通过源码追踪从RequestQueue入手：
如果android版本大于等于2.3调用基于HttpURLConnection的HurlStack,否则就调用基于HttpClient的
HttpClient的HttpClientStack。并创建RequestQueue，调用start()方法。
CacheDispatcher是缓存调度线程，并调用了start()方法，在循环中调用NetworkDispatcher的start()方法，
NetworkDispatcher是网络调度线程，默认情况下mDispatchers.length为4，默认开启四个网络调度线程，也就是
说有五个线程在后台运行并等待请求到来。接下来我们创建各种Request，并调用RequestQueue的add()方法。
通过判断request.shouldCache()，来判断是否可以缓存，默认可缓存，如果不能缓存则将请求添加到网络请求队列
中，如果能缓存就判断之前是否有执行相同的请求且还没有返回结果的，如果有的话将请求加入mWaitingRequests
队列，不再重复请求，如果没有将请求加入缓存队列mCacheQueue，同时加入mWaitingRequests队列中用来做下次
同样请求来时的重复判断依据。RequestQueue的add()方法并没有做什么请求网络或者对缓存进行操作。当请求添加
到网络队列或缓存队列时，这时后台的网络调度线程和缓存调度线程轮询各自的请求队列发现有请求任务则开始执行。
CacheDispatcher缓存调度线程：
首先从缓存队列取出请求，判断请求是否被取消了，如果没有则判断该请求是否有缓存的响应，没有则加入网络
请求队列进行下一个迭代请求，然后判断请求是否过期，过期则加入网络请求队列并设置缓存进行下一个迭代请求，
有缓存响应并请求未过期则对缓存响应进行解析并回调给主线程。
NetworkDispatcher网络调度线程：
网络调度线程也是从队列中取出请求并且判断是否被取消了，如果没取消就去请求网络得到响应并回调给主线程。
请求网络时调用mNetwork.performRequest(request)，这个mNetwork是一个接口，实现它的类是BasicNetwork。
请求网络后会将响应结果存到缓存中，结果响应成功则调用mDelivery.postResponse(request, response)回调给主线程。
ResponseDelivery是一个接口，实现类是ExecutorDelivery。
postResponse方法中调用了ResponseDeliveryRunnable，该run方法中调用了mRequest.deliverResponse(mResponse.result)，
这就是实现Request抽象类必须要实现的方法。
在Request子类deliverResponse方法中调用了mListener.onResponse(response)
最终将response回调给了Response.Listener的onResponse()方法
BasicNetwork：
调用的是HttpStack的performRequest()方法请求网络，接下来根据不同的响应状态码来返回不同的NetworkResponse
HttpStack也是一个接口，实现它的两个类HurlStack和HttpClientStack

网络框架OkHttp2.x
会从很多常用的连接问题中自动恢复
ex：如果服务器配置了多个IP地址，当第一个IP连接失败时，OkHttp会自动尝试下一个IP
处理了代理服务器问题和SSL握手失败问题
OkHttp post和get不同的就是要创建RequestBody传入Request中
请求缓存设置
设置cacheControl为CacheControl.FORCE_NETWORK，表示请求会一直请求网络得到数据
支持连接、读取和写入超时的时间设置：
setConnectTimeout
setWriteTimeout
setReadTimeout
使用call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException
当用户离开一个应用时或者跳到其他界面时，使用Call.cancel()可以节约网络资源，不管同步还是异步的call都可以取消
也可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。
之后就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call
自己封装OkHttp2.x
1.避免重复代码调用
2.请求结果回调到UI线程中

网络框架OkHttp3
异步GET请求与2.x一样
异步POST请求差别是没有FormEncodingBuilder这个类，替代它的是功能更加强大的FormBody
异步上传文件(POST请求)
异步下载文件













