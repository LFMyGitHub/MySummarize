HTTP简介：
应用层的面向对象的协议，简便、快速，适用于分布式超媒体信息系统。1990年提出
特点：
1.支持c/s(客户/服务器)模式
2.简单快速：客户像服务器请求服务时，只需传送请求方法(GET/POST/HEAD)和路径，每种方法规定了客户与服务
器联系的类型不同。因为HTTP协议简单，使得HTTP服务器程序规模小，因而通讯速度非常快。
3.灵活：允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记。
4.无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户应答后，即断开连接。节省传输时间。
5.无状态：协议对于事务处理没有记忆能力。后续处理需要前面信息必须重传，导致每次连接传送的数据量增大。
服务器不需要先前信息时应答就快。
格式：
http://host[":"port][abs_path]
http表示通过HTTP协议来定位网络资源
host表示合法的Internet主机域名或IP地址
port指定一个端口号，为空则默认使用端口80
abs_path指定请求资源的URI

HTTP请求报文
https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/http_request.jpg
一般格式：请求行、请求报头、空行、请求数据4个部分组成。
请求行：请求方法、URL字段和HTTP协议版本组成
格式：Method Request-URI HTTP-Version CRLF
Method表示请求方法
Request-URI是一个统一资源标识符
HTTP-Version表示请求的HTTP协议版本
CRLF表示回车和换行(除作为结尾的CRLF外，不允许出现单独的CR或LF字符)
HTTP八种请求方法：
1.GET：请求获取Request-URI所标识的资源
2.POST：在Request-URI所标识的资源后附加新的数据
3.HEAD：请求获取Request-URI所标识的资源的响应消息报头
4.PUT：请求服务器存储一个资源，并用Request-URI作为其标识
5.DELETE：请求服务器删除Request-URI所标识的资源
6.TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断
7.CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
8.OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求
ex:GET http://xxxxx HTTP/1.1
请求报头：
在请求行之后会有0个或多个请求报头，每个请求报头包含一个名字和值，用:分割。请求报头以一个空行发送回车和
换行符通知服务器以下不会有请求报头。
请求数据：
请求数据不在GET方法中使用，而是在POST方法中使用。POST方法适用于需要客户填写表单的场合，与请求数据相关
的最常用的请求头是Content-Type和Content-Length

HTTP响应报文
https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/http_reponse.jpg
一般格式：由状态行、消息报头、空行、响应正文组成。
状态行
格式：HTTP-Version Status-Code Reason-Phrase CRLF
HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述
状态码由三个数字组成，第一个数字定义了响应的类别，且有五中可能：
100-199：指示信息，表示请求已接收，继续处理
200-299：请求成功，表示请求已被成功接收，理解，接受
300-399：重定向，要完成请求必须要进行更进一步的操作
400-499：客户端错误，请求有语法错误，或请求无法实现
500-599：服务器端错误，服务器未能实现合法的请求
常见状态码：
200 OK：客户端请求成功
400 Bad Request：客户端请求有语法错误，不能被服务端理解
401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
403 Forbidden：服务器收到请求，拒绝提供服务
500 Internal Server Error：服务器发生不可预期的错误
503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常
ex：HTTP/1.1 200 OK

HTTP消息报头
通用报头：既可以出现在请求报头，也可以出现响应报头中
Date：消息产生的时间和日期
Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定close选项，通知服务器在响应完成之后关闭连接。
Cache-Control：指定缓存指令，缓存指令是单向的(响应中出现的缓存指令在请求中未必会出现)，且是独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)
请求报头：通知服务器关于客户端请求的信息
典型请求头：
Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
User-Agent：发送请求的浏览器类型、操作系统等信息
Accept：客户端可识别的内容类型列表，用于指定客户端接收哪些类型的信息
Accept-Encoding：客户端可识别的数据编码
Accept-Language：表示浏览器所支持的语言类型
Connection：允许客户端或服务器指定与请求/响应连接有关的选项，例如设置为Keep-Alive则表示保持连接
Transfer-Encoding：告知接收端为保证报文的可靠传输，对报文采用什么编码方式
响应报头：服务器传递自身信息的响应
常见响应报头：
Location：用于重定向接受者到一个新位置，常用在更换域名的时候
Server：包含服务器用来处理请求的系统信息，与User-Agent请求报头对应
实体报头：定义被传输资源的信息，可以用于请求，也可以用于响应
常用实体报头：
Content-Type：指明发送给接受者的实体正文的媒体类型(MIME)
Content-Length：实体正文的长度
Content-Language：描述资源所用的自然语言，没有设置则认为实体内容将提供给所有的语言阅读
Content-Encoding：指明数据的压缩方式，因而要获得Content-Type报头域中所引用的媒体类型必须采用相应的解码机制。
Last-Modified：指示资源的最后修改日期
Expires：实体报头给出响应过期的时间和日期

利用Fiddler工具进行网络数据抓包

HttpClient与HttpURLConnection
HttpClient：
Android SDK中包含了HttpClient，在Android6.0版本删除了该类库，如果仍想使用解决办法是：
Eclipse：在libs中加入org.apache.http.legacy.jar(**sdk/platforms/android-23/optional目录下)
Android Studio：相应module下build.gradle中加入：
android{
    useLibrary 'org.apache.http.legacy'
}

HttpURLConnecion

网络通信框架Volley(2013Google)
应用场景：数据量不大，通信频繁的操作
基于请求队列依次请求，开发者只需要将请求放入请求队列就可以了。
Volley结构图：https://github.com/LFMyGitHub/MySummarize/blob/master/httplibrary/src/main/res/drawable/volley.png
Volley分为三个线程：主线程、缓存调度线程、网络调度线程，首先请求会加入缓存队列，如果发现相应的缓存结果就
直接读取缓存并解析，然后回调给主线程；如果没在缓存中找到结果，则将这条请求加入网络队列，然后发送HTTP请求，
解析响应并写入缓存，并回调给主线程。
通过源码追踪从RequestQueue入手：
如果android版本大于等于2.3调用基于HttpURLConnection的HurlStack,否则就调用基于HttpClient的
HttpClient的HttpClientStack。并创建RequestQueue，调用start()方法。
CacheDispatcher是缓存调度线程，并调用了start()方法，在循环中调用NetworkDispatcher的start()方法，
NetworkDispatcher是网络调度线程，默认情况下mDispatchers.length为4，默认开启四个网络调度线程，也就是
说有五个线程在后台运行并等待请求到来。接下来我们创建各种Request，并调用RequestQueue的add()方法。
通过判断request.shouldCache()，来判断是否可以缓存，默认可缓存，如果不能缓存则将请求添加到网络请求队列
中，如果能缓存就判断之前是否有执行相同的请求且还没有返回结果的，如果有的话将请求加入mWaitingRequests
队列，不再重复请求，如果没有将请求加入缓存队列mCacheQueue，同时加入mWaitingRequests队列中用来做下次
同样请求来时的重复判断依据。RequestQueue的add()方法并没有做什么请求网络或者对缓存进行操作。当请求添加
到网络队列或缓存队列时，这时后台的网络调度线程和缓存调度线程轮询各自的请求队列发现有请求任务则开始执行。
CacheDispatcher缓存调度线程：
首先从缓存队列取出请求，判断请求是否被取消了，如果没有则判断该请求是否有缓存的响应，没有则加入网络
请求队列进行下一个迭代请求，然后判断请求是否过期，过期则加入网络请求队列并设置缓存进行下一个迭代请求，
有缓存响应并请求未过期则对缓存响应进行解析并回调给主线程。
NetworkDispatcher网络调度线程：
网络调度线程也是从队列中取出请求并且判断是否被取消了，如果没取消就去请求网络得到响应并回调给主线程。
请求网络时调用mNetwork.performRequest(request)，这个mNetwork是一个接口，实现它的类是BasicNetwork。
请求网络后会将响应结果存到缓存中，结果响应成功则调用mDelivery.postResponse(request, response)回调给主线程。
ResponseDelivery是一个接口，实现类是ExecutorDelivery。
postResponse方法中调用了ResponseDeliveryRunnable，该run方法中调用了mRequest.deliverResponse(mResponse.result)，
这就是实现Request抽象类必须要实现的方法。
在Request子类deliverResponse方法中调用了mListener.onResponse(response)
最终将response回调给了Response.Listener的onResponse()方法
BasicNetwork：
调用的是HttpStack的performRequest()方法请求网络，接下来根据不同的响应状态码来返回不同的NetworkResponse
HttpStack也是一个接口，实现它的两个类HurlStack和HttpClientStack

网络框架OkHttp2.x
会从很多常用的连接问题中自动恢复
ex：如果服务器配置了多个IP地址，当第一个IP连接失败时，OkHttp会自动尝试下一个IP
处理了代理服务器问题和SSL握手失败问题
OkHttp post和get不同的就是要创建RequestBody传入Request中
请求缓存设置
设置cacheControl为CacheControl.FORCE_NETWORK，表示请求会一直请求网络得到数据
支持连接、读取和写入超时的时间设置：
setConnectTimeout
setWriteTimeout
setReadTimeout
使用call.cancel()可以立即停止掉一个正在执行的call。如果一个线程正在写请求或者读响应，将会引发IOException
当用户离开一个应用时或者跳到其他界面时，使用Call.cancel()可以节约网络资源，不管同步还是异步的call都可以取消
也可以通过tags来同时取消多个请求。当你构建一请求时，使用RequestBuilder.tag(tag)来分配一个标签。
之后就可以用OkHttpClient.cancel(tag)来取消所有带有这个tag的call
自己封装OkHttp2.x
1.避免重复代码调用
2.请求结果回调到UI线程中

网络框架OkHttp3
异步GET请求：与2.x一样
异步POST请求：差别是没有FormEncodingBuilder这个类，替代它的是功能更加强大的FormBody
异步上传文件(POST请求)：证书问题
异步下载文件
设置超时时间和缓存：不能通过OkHttpClient直接设置超时时间和缓存了，而是通过OkHttpClient.Builder来设置
取消请求和封装：与OkHttp2.x一样
源码分析：
请求网络需要OkHttpClient.newCall(request)进行execute或者enqueue操作，newCall返回的是一个RealCall对象，
RealCall的同步异步调用最终都是通过dispatcher来完成的。
Dispatcher任务调度：
maxRequests：最大并发请求数
maxRequestsPerHost：每个主机最大请求数
executorService：消费者线程池
readyAsyncCalls：将要运行的异步请求队列
runningAsyncCalls：正在运行的 异步请求队列
runningSyncCalls：正在运行的同步请求队列
两个构造函数，有参构造函数可自己设置线程池，如果没有设定线程池则会在网络请求前自己创建，该线程池类似
于CachedThreadPool比较适合执行大量的耗时比较小的任务。其中用到了SynchronousQueue。
SynchronousQueue最大的特点就是put/take是成对调用的：先调put，线程会阻塞在那；直到另外一个线程调用了
take，2个线程才同时解锁。
唤醒规则：队列模式：最先调用put的线程，最先被take唤醒；栈模式：最后调用put的线程，最先被take唤醒
当正在运行的异步请求队列中的数量小于64并且正在运行的请求主机数小于5时则把请求加载到runningAsyncCalls
中并在线程池中执行，否则就加入到readyAsyncCalls中进行缓存等待
线程池中传进来的参数就是AsyncCall,它是RealCall的内部类，内部实现了execute方法，无论请求结果如何都会执
行client.dispatcher().finished(this)
finished方法将请求移出正在运行的请求队列，并执行promoteCalls()方法拉取下一个请求
继续看AsyncCall的execute方法，getResponseWithInterceptorChain(forWebSocket)处返回一个Response对象
getResponseWithInterceptorChain方法中创建了一个拦截器链并执行它的proceed方法
proceed方法每次从拦截器列表中取出拦截器，当取出所有拦截器之后才会执行网络请求getResponse方法
getResponse方法创建HttpEngine类，并调用sendRequest和readResponse方法
sendRequest发送请求主要做了缓存策略，cacheCandidate是上次与服务器交互缓存的Response，这里的缓存都是
基于Map，key是请求中url的md5，value是在文件中查询到的缓存，页面置换基于LRU算法，它是一个可以读取缓存
Header的Response。根据cacheStrategy的处理得到了networkRequest和cacheResponse这两个值，根据这两个值的
数据是否为null来进行进一步的处理，当networkRequest和cacheResponse都为null的情况也就是不进行网络请求
并且缓存不存在或者过期，这时候则返回504错误；当networkRequest 为null时也就是不进行网络请求，而且缓存
可以使用时则直接返回缓存；其他的情况则请求网络。
readResponse方法发起刷新请求头部和请求体，解析HTTP响应头部。如果有缓存并且可用则用缓存的数据并更新缓
存，否则就用网络请求返回的数据
validate方法检查缓存是否可用，如缓存果过期或者强制放弃缓存，在此情况下，缓存策略全部交给服务器判断，
客户端只用发送条件get请求即可，如果缓存是有效的，则返回304 Not Modifiled，否则直接返回body。条件get
请求有两种方式一种是Last-Modified-Date，一种是 ETag。这里采用了Last-Modified-Date，通过缓存和网络请
求响应中的Last-Modified来计算是否是最新数据，如果是则缓存有效
失败重连：
回到RealCall的getResponse方法，当发生IO或者Route异常时会执行engine.recover(e, null)方法，重新创建了
HttpEngine并返回，完成重连
OkHttp请求网络流程图：
https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_okhttp.png
复用连接池：
连接网络三次握手
第一次：建立连接
第二次：服务器接收到客户端的SYN报文段
第三次：客户端收到服务器的SYN+ACK报文段
断开连接四次分手
第一次：主机1向主机2发送一个FIN报文段，表示主机1没有数据要发送给主机2了
第二次：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段
第三次：主机2向主机1发送FIN报文段，请求关闭连接
第四次：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段
https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_okhttp.jpg
大量的连接每次连接关闭都要三次握手四次分手会造成性能低下，因此http有一种叫做keepalive connections的
机制，它可以在传输数据后仍然保持连接，当客户端需要再次获取数据时，直接使用刚刚空闲下来的连接而不需要再次握手
OkHttp支持5个并发KeepAlive，默认链路生命为5分钟(链路空闲后，保持存活的时间)
在OkHttp高层代码调用中，使用了类似于引用计数的方式跟踪Socket流的调用，这里的计数对象是StreamAllocation，
它被反复执行aquire与release操作，这两个函数其实是在改变RealConnection中的List<Reference<StreamAllocation>>的大小
RealConnection是socket物理连接的包装，它里面维护了List<Reference<StreamAllocation>>的引用。
List中StreamAllocation的数量也就是socket被引用的计数，如果计数为0的话，说明此连接没有被使用就是空闲的，
如果计数不为0，则表示上层代码仍然引用，就不需要关闭连接
连接池的类位于OkHttp3.ConnectionPool：
executor线程池，类似于CachedThreadPool，需要注意的是这种线程池的工作队列采用了没有容量的SynchronousQueue
Deque<RealConnection>，双向队列，双端队列同时具有队列和栈性质，经常在缓存中被使用，里面维护了RealConnection也就是socket物理连接的包装
RouteDatabase，它用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去
ConnectionPool构造函数默认的空闲的socket最大连接数为5个，socket的keepAlive时间为5分钟
OkHttpClient的构造函数中调用了new Builder()，ConnectionPool实例化在此处
ConnectionPool提供对Deque<RealConnection>进行操作的方法分别为put、get、connectionBecameIdle和evictAll
几个操作。分别对应放入连接、获取连接、移除连接和移除所有连接操作
put操作：在添加到Deque<RealConnection>之前首先要清理空闲的线程
get操作：遍历connections缓存列表，当某个连接计数的次数小于限制的大小并且request的地址和缓存列表中此
连接的地址完全匹配。则直接复用缓存列表中的connection作为request的连接
OkHttp是根据StreamAllocation引用计数是否为0来实现自动回收连接的
executor.execute(cleanupRunnable)清理闲置线程，线程不断的调用cleanup来进行清理，并返回下次需要清理的
间隔时间，然后调用wait进行等待以释放锁与时间片，当等待时间到了后，再次进行清理，并返回下次要清理的间
隔时间，如此循环下去
cleanup根据连接中的引用计数来计算空闲连接数和活跃连接数，然后标记出空闲的连接，如果空闲连接keepAlive
时间超过5分钟，或者空闲连接数超过5个，则从Deque中移除此连接。接下来根据空闲连接或者活跃连接来返回下
次需要清理的时间数：如果空闲连接大于0则返回此连接即将到期的时间，如果都是活跃连接并且大于0则返回默认
的keepAlive时间5分钟，如果没有任何连接则跳出循环并返回-1。通过pruneAndGetAllocationCount方法来判断连
接是否闲置的，如果pruneAndGetAllocationCount方法返回值大于0则是空闲连接，否则就是活跃连接
pruneAndGetAllocationCount方法首先遍历传进来的RealConnection的StreamAllocation列表，如果StreamAllocation
被使用则接着遍历下一个StreamAllocation，如果StreamAllocation未被使用则从列表中移除。如果列表为空则说
明此连接没有引用了，则返回0，表示此连接是空闲连接，否则就返回非0的数表示此连接是活跃连接
复用核心：用Deque<RealConnection>来存储连接，通过put、get、connectionBecameIdle和evictAll几个操作来
对Deque进行操作，另外通过判断连接中的计数对象StreamAllocation来进行自动回收连接

网络框架Retrofit2(基于OkHttp实现)
https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_retrofix.png
准确来说，Retrofit 是一个RESTful的HTTP网络请求框架的封装。
原因：网络请求的工作本质上是OkHttp 完成，而 Retrofit仅负责网络请求接口的封装
网络框架对比：https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_retrofix_compared.png
Retrofit通过使用大量的设计模式进行功能模块的解耦，本质与一般网络请求一样
https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_retrofix_specific_process.png
网络请求淘宝ip库
@Query：查询参数
@QueryMap：查询参数较多，用Map集合在一起统一传递
@Path：代替路径
@Body与@Post一起使用，提供查询主体内容
@Headers：添加头部信息
@Multipart：上传文件
@FormUrlEncoded：标明这是一个表单请求
@Part：单文件上传
@PartMap：多文件上传
Retrofit通过构建模式构建出来，内部调用Platform的get方法，最终调用findPlatform方法根据平台提供不同线
程池，build方法构建Retrofit必须指定baseUrl，callFactory默认为构建Retrofit传入的，如果为空直接创建
OkHttpClient对象，callbackExecutor用来将回调传递到UI线程。adapterFactories主要用于存储对Call进行转化
的对象，converterFactories主要用于存储转化数据对象
通过Retrofit的create方法生成接口的动态代理对象(Proxy.newProxyInstance)，调用代理对象方法最终会调用
InvocationHandler的invoke方法，它有3个参数，第一个是代理对象，第二个是调用的方法，第三个是方法的参数。
loadServiceMethod(method)中的method就是我们定义的方法
loadServiceMethod方法首先会从serviceMethodCache查询传入的方法是否有缓存，如果有就用缓存的ServiceMethod，
如果没有就创建一个，并加入serviceMethodCache缓存起来
ServiceMethod构建调用了createCallAdapter方法，它最终会得到我们在构建Retrofit调用build方法时
adapterFactories添加的对象的get方法
adapterFactories列表默认会添加defaultCallAdapterFactory，defaultCallAdapterFactory指的是ExecutorCallAdapterFactory
ExecutorCallAdapterFactory的get方法会得到CallAdapter对象，它的responseType方法会返回数据的真实类型，
比如Call<IpModel>，它就会返回IpModel。adapt方法会创建ExecutorCallbackCall，它会将call的回调转发至UI线程
接着回到ServiceMethod的 build方法，调用CallAdapter的responseType得到的是返回数据的真实类型
createResponseConverter方法来遍历converterFactories列表中存储的Converter.Factory，并返回一个合适的Converter用来转换对象
遍历parseMethodAnnotation方法来对请求方式（比如GET、POST）和请求地址进行解析
对方法中的参数注解进行解析（比如@Query、@Part）。最后创建ServiceMethod类并返回
回过头来查看Retrofit的create方法，在调用了loadServiceMethod方法后会创建OkHttpCall，OkHttpCall的构造函
数只是进行了赋值操作。紧接着调用serviceMethod.callAdapter.adapt(okHttpCall)，它会创建ExecutorCallbackCall
(对Call的封装，添加了通过callbackExecutor将请求回调到UI线程)
ExecutorCallbackCall的enqueue方法最终调用的是delegate(OkHttpCall)的enqueue方法
OkHttpCall的enqueue方法内部调用parseResponse方法，根据返回的不同状态码code值做不同的操作，如果顺利则
调用toResponse方法，内部通过responseConverter(createResponseConverter方法返回的Converter)最终创建一个
ResponseBodyConverter
调用responseConverter.convert是为了转换为特定的数据格式。
Call的enqueue方法主要做的就是用OKHttp来请求网络并将返回的Response进行数据转换并回调给UI线程









