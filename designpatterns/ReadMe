设计模式
https://github.com/LFMyGitHub/MySummarize/blob/master/img/img_design_patterns.png

单例模式
定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。
使用场景：避免产生多个对象消耗过多资源。
实现关键点：
①构造函数私有
②通过一个静态或枚举方法返回单例类对象
③确保 对象有且只有一个，尤其在多线程下
④确保对象反序列化时不会重新构建。
饿汉模式：构造函数私有化，通过静态方法返回静态对象[声明时初始化]
懒汉模式：第一次调用时初始化[synchronized关键字同步方法，多线程情况下保证单例对象唯一]
优点：使用时初始化，一定程度上节约资源
缺点：第一次加载慢，每次调用时进行方法同步会消耗不必要的资源
DCL双重检锁：两次判空，第一次判空避免不必要同步，第二次判空创建实例。
优点：需要时初始化，保证线程安全，初始化后调用getInstance方法不进行同步锁
sInstance = new Singleton()最终会编译成多条汇编指令
①给Singleton实例分配内存
②调用构造函数初始化成员字段
③将对象指向分配的内存空间(此时sInstance不为空)
DCL失效：Java允许编译器乱序执行，多线程并发执行时A线程执行顺序①③②在③执行结束②执行开始时B线程获取
对象不为空直接使用出错。
JDK1.5之后关键字volatile[影响性能]关键字可保证对象每次都从主内存中读取，避免Java内存模型[JDK1.5之前JMM
中Cache、寄存器到主内存回写顺序第二三顺序是无法保证的]造成的错误
静态内部类单例模式：
第一次加载时不会初始化，第一次调用getInstance时初始化，确保线程安全，对象唯一同时也延迟了单例的实例化
虚拟机会保证一个类的构造器在多线程环境中被正确加锁、同步，同一个类加载器下，一个类型只会被初始化一次
枚举单例：默认枚举实例的创建是线程安全的，任何情况下都是一个单例。[以上几种反序列化情况会重新创建对象]
容器管理单例
======================================================================================================
